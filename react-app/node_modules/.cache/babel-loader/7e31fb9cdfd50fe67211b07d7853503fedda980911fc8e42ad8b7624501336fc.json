{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\seba\\\\Documents\\\\pagina\\\\react-app\\\\src\\\\components\\\\HtmlLoader.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState, useRef } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function HtmlLoader({\n  src\n}) {\n  _s();\n  const [content, setContent] = useState(\"Loading...\");\n  const containerRef = useRef(null);\n  useEffect(() => {\n    let cancelled = false;\n    const appendedScripts = [];\n    fetch(src).then(r => r.text()).then(text => {\n      if (cancelled) return;\n\n      // extract body content if it's a full HTML\n      const bodyMatch = text.match(/<body[^>]*>([\\s\\S]*)<\\/body>/i);\n      const full = bodyMatch ? bodyMatch[1] : text;\n\n      // extract scripts and remove them from the html content\n      const scripts = [];\n      const cleaned = full.replace(/<script\\b([^>]*)>([\\s\\S]*?)<\\/script>/gi, (_, attrs, inner) => {\n        const srcMatch = attrs && attrs.match(/src=(['\"])\\s*([^\"']+)\\s*\\1/);\n        scripts.push({\n          src: srcMatch ? srcMatch[2] : null,\n          content: inner\n        });\n        return \"\"; // remove script from content\n      });\n      setContent(cleaned);\n\n      // execute scripts after the HTML has been injected\n      // small timeout to ensure the DOM node has the innerHTML applied\n      setTimeout(() => {\n        if (cancelled) return;\n        const base = new URL(src, window.location.href);\n        scripts.forEach(s => {\n          const el = document.createElement(\"script\");\n          el.async = false;\n          if (s.src) {\n            // resolve relative script URLs\n            try {\n              el.src = new URL(s.src, base).href;\n            } catch (e) {\n              el.src = s.src;\n            }\n          } else {\n            el.text = s.content;\n          }\n\n          // append to the container so the script runs in page context\n          try {\n            (containerRef.current || document.body).appendChild(el);\n            appendedScripts.push(el);\n          } catch (e) {\n            // fallback: append to body\n            document.body.appendChild(el);\n            appendedScripts.push(el);\n          }\n        });\n\n        // If the injected content doesn't include the Google Maps iframe, append it as a fallback\n        try {\n          const container = containerRef.current;\n          const hasMap = container && container.querySelector && container.querySelector('iframe[src*=\"google.com/maps\"]');\n          if (!hasMap && container) {\n            const map = document.createElement(\"iframe\");\n            map.src = \"https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d1614.3218665764903!2d-70.6846115622053!3d-33.5988123187725!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x9662d97348990efd%3A0xce94f054c9e23bbf!2sCarlos%20Condell%2C%20San%20Bernardo%2C%20Regi%C3%B3n%20Metropolitana!5e0!3m2!1ses-419!2scl!4v1757420353991!5m2!1ses-419!2scl\";\n            map.width = \"100%\";\n            map.height = \"450\";\n            map.style.border = \"0\";\n            map.loading = \"lazy\";\n            map.setAttribute(\"referrerpolicy\", \"no-referrer-when-downgrade\");\n            container.appendChild(map);\n            appendedScripts.push(map);\n          }\n        } catch (e) {\n          // ignore fallback failure\n        }\n      }, 0);\n    }).catch(err => setContent('<pre style=\"color:red\">Error loading content</pre>'));\n    return () => {\n      cancelled = true;\n      // remove appended scripts\n      appendedScripts.forEach(s => s.remove());\n    };\n  }, [src]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: containerRef,\n    dangerouslySetInnerHTML: {\n      __html: content\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 103,\n    columnNumber: 5\n  }, this);\n}\n_s(HtmlLoader, \"HMj0BEM7MITGCH3nZUsHtbesY/4=\");\n_c = HtmlLoader;\nvar _c;\n$RefreshReg$(_c, \"HtmlLoader\");","map":{"version":3,"names":["React","useEffect","useState","useRef","jsxDEV","_jsxDEV","HtmlLoader","src","_s","content","setContent","containerRef","cancelled","appendedScripts","fetch","then","r","text","bodyMatch","match","full","scripts","cleaned","replace","_","attrs","inner","srcMatch","push","setTimeout","base","URL","window","location","href","forEach","s","el","document","createElement","async","e","current","body","appendChild","container","hasMap","querySelector","map","width","height","style","border","loading","setAttribute","catch","err","remove","ref","dangerouslySetInnerHTML","__html","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/seba/Documents/pagina/react-app/src/components/HtmlLoader.jsx"],"sourcesContent":["import React, { useEffect, useState, useRef } from \"react\";\r\n\r\nexport default function HtmlLoader({ src }) {\r\n  const [content, setContent] = useState(\"Loading...\");\r\n  const containerRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    let cancelled = false;\r\n    const appendedScripts = [];\r\n\r\n    fetch(src)\r\n      .then((r) => r.text())\r\n      .then((text) => {\r\n        if (cancelled) return;\r\n\r\n        // extract body content if it's a full HTML\r\n        const bodyMatch = text.match(/<body[^>]*>([\\s\\S]*)<\\/body>/i);\r\n        const full = bodyMatch ? bodyMatch[1] : text;\r\n\r\n        // extract scripts and remove them from the html content\r\n        const scripts = [];\r\n        const cleaned = full.replace(\r\n          /<script\\b([^>]*)>([\\s\\S]*?)<\\/script>/gi,\r\n          (_, attrs, inner) => {\r\n            const srcMatch = attrs && attrs.match(/src=(['\"])\\s*([^\"']+)\\s*\\1/);\r\n            scripts.push({\r\n              src: srcMatch ? srcMatch[2] : null,\r\n              content: inner,\r\n            });\r\n            return \"\"; // remove script from content\r\n          }\r\n        );\r\n\r\n        setContent(cleaned);\r\n\r\n        // execute scripts after the HTML has been injected\r\n        // small timeout to ensure the DOM node has the innerHTML applied\r\n        setTimeout(() => {\r\n          if (cancelled) return;\r\n          const base = new URL(src, window.location.href);\r\n\r\n          scripts.forEach((s) => {\r\n            const el = document.createElement(\"script\");\r\n            el.async = false;\r\n            if (s.src) {\r\n              // resolve relative script URLs\r\n              try {\r\n                el.src = new URL(s.src, base).href;\r\n              } catch (e) {\r\n                el.src = s.src;\r\n              }\r\n            } else {\r\n              el.text = s.content;\r\n            }\r\n\r\n            // append to the container so the script runs in page context\r\n            try {\r\n              (containerRef.current || document.body).appendChild(el);\r\n              appendedScripts.push(el);\r\n            } catch (e) {\r\n              // fallback: append to body\r\n              document.body.appendChild(el);\r\n              appendedScripts.push(el);\r\n            }\r\n          });\r\n\r\n          // If the injected content doesn't include the Google Maps iframe, append it as a fallback\r\n          try {\r\n            const container = containerRef.current;\r\n            const hasMap =\r\n              container &&\r\n              container.querySelector &&\r\n              container.querySelector('iframe[src*=\"google.com/maps\"]');\r\n            if (!hasMap && container) {\r\n              const map = document.createElement(\"iframe\");\r\n              map.src =\r\n                \"https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d1614.3218665764903!2d-70.6846115622053!3d-33.5988123187725!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x9662d97348990efd%3A0xce94f054c9e23bbf!2sCarlos%20Condell%2C%20San%20Bernardo%2C%20Regi%C3%B3n%20Metropolitana!5e0!3m2!1ses-419!2scl!4v1757420353991!5m2!1ses-419!2scl\";\r\n              map.width = \"100%\";\r\n              map.height = \"450\";\r\n              map.style.border = \"0\";\r\n              map.loading = \"lazy\";\r\n              map.setAttribute(\"referrerpolicy\", \"no-referrer-when-downgrade\");\r\n              container.appendChild(map);\r\n              appendedScripts.push(map);\r\n            }\r\n          } catch (e) {\r\n            // ignore fallback failure\r\n          }\r\n        }, 0);\r\n      })\r\n      .catch((err) =>\r\n        setContent('<pre style=\"color:red\">Error loading content</pre>')\r\n      );\r\n\r\n    return () => {\r\n      cancelled = true;\r\n      // remove appended scripts\r\n      appendedScripts.forEach((s) => s.remove());\r\n    };\r\n  }, [src]);\r\n\r\n  return (\r\n    <div ref={containerRef} dangerouslySetInnerHTML={{ __html: content }} />\r\n  );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}